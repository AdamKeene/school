assignment 1:
assignment 2: 
doubling size is faster bc remains O(1) instead of O(n), as it continues to grow the size continues to grow as well, also memory allocation
assignment 3:
MAD method multiply add divide: compression method which helps avoild collisions
polynomial hash: 128 is arbitrary but power of 2 is efficient

sorting:
heap-sort: best for small to medium sized data sets because data fits into main memory, runs well when it runs in place
quick-sort: usually fastest in large data sets nlogn but worst case n^2 is slow when data has to be guaranteed at a certain speed
merge-sort: nlogn worst case but doesn't run in place, best when input is stratified across memory levels
radix sort: faster when range is limited compared to n, specific use cases
